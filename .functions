#!/bin/bash

# -----------------------------------------------------------------------------
# helpers to search through specific file types

# find file under pwd - v `fs main.yml`
fs() { find . -type f -name "$1" 2> /dev/null ;}
# find file anywhere - v `ff roles main`
ff() { find "$1" -type f -name "$2" 2> /dev/null ;}
lstree() { tree -aC -I "node_modules|.git|bower_components|venv" --dirsfirst "$@" | less -R ;}

# JS files
jf() { ff "$@" "*.js" | grep -vE "node_modules|bower_components|\.min" ;}
js() { jf "$1" | xargs grep -s "$2" ;}

# markdowns
mf() { ff "$@" "*.md" | grep -vE "node_modules|bower_components" ;}
ms() { mf "$1" | xargs grep -s "$2" ;}

# RS files
rf() { ff "$@" "*.rs" ;}
rs() { rf "$1" | xargs grep -s "$2" ;}

# PY files
pyf() { ff "$@" "*.py" | grep -vE "site-packages|node_modules|venv|.eggs" ;}
pys() { pyf "$1" | xargs grep -s "$2" ;}

# C++ files
cf() { find "$@" -type f -name "*.cpp" -o -name "*.h" -o -name "*.c" 2> /dev/null ;}
cs() { cf "$1" | xargs grep -s "$2" ;}
hf() { ff "$@" "*.h" ;}
hs() { hf "$1" | xargs grep -s "$2" ;}

# CMakeLists from PWD
srchcmake() { ff . "CMakeLists.txt" | xargs grep -s "$1" ;}

# -----------------------------------------------------------------------------
# package manager abstraction - mostly for my own memory

if lsb_release -ds | grep -qEi "debian|mint|buntu"; then
  paks() { apt-cache search "$1"; } # find package by name
  pakf() { dpkg -S "$1" ;}
  qlist() { dpkg-query -L "$1" ;}
  paki() { sudo apt-get install "$1" ;}
  pakr() { sudo apt-get remove "$1" ;}
elif lsb_release -ds | grep -qEi "Gentoo"; then
  paks() { eix -c "$1" ;}
  pakf() { equery belongs "$1" ;}
  # canonical qlist
  paki() { sudo emerge "$1" ;}
  pakr() { sudo emerge -cav "$1" ;}
elif hash pacman 2> /dev/null; then
  paks() { pacman -Ss "$1" ;} # -Qs for what you have installed
  pakf() { pacman -Qo "$1" ;} # -Fs for arbitrary files in any package (-Fy first)
  qlist() { pacman -Ql "$1" ;}
  paki() { sudo pacman -S "$1" ;}
  pakr() { sudo pacman -R "$1" ;}
elif hash yum 2> /dev/null; then
  paks() { yum search "$1" ;}
  pakf() { yum whatprovides "$1" ;}
  qlist() { repoquery --list "$1" ;} # from yum-utils
  paki() { sudo yum install "$1" ;}
  pakr() { sudo yum remove "$1" ;}
fi

# -----------------------------------------------------------------------------
# misc

zz() {
  guake --rename-tab="${PWD##*/}" -i "$(guake -g)"
}
zzh() {
  guake --rename-tab="$1" -i "$(guake -g)"
  # shellcheck disable=SC2068
  ssh $@
}

# Create a new directory and enter it
mkd() { mkdir -p "$@" && cd "$@" || return 1 ;}

kill-tabs() { pkill -u "$USER" -f "chrome.*renderer" ;}

glscommand() {
  local -r dirs=$(find . -maxdepth 1 -mindepth 1 -type "d")
  local -r command="$1"
  dir=$PWD
  for d in $dirs; do
    cd "$d" || false
    echo -en "$(tput setaf 33)${d:2} "
    if [[ -d .git ]]; then
      echo -en "$(tput setaf 136)$(${command})$(tput sgr0)"
    fi
    echo
    cd ..
  done
  cd "$dir" || true
}

# ls | git prompt
gls() { glscommand "show_git_differences" ;}
# ls | git whoami
glsd() { glscommand "git whoami" ;}

# convert yaml to json:
# yaml file
# yaml file [json key/args]
yaml() {
  if [ -n "$2" ]; then
    # shellcheck disable=SC2068
    js-yaml "$1" | json $@
  else
    js-yaml "$1"
  fi
}

# force monitor refresh rate
# hopefully find a better solution, but .xprofile currently doesnt work for this
refresh-benq() {
  if [ "$(hostname)" = "kjttks" ]; then
    # Main screen refresh rate
    xrandr --output DVI-I-1 --mode 1920x1080 --rate 144
  fi
  xrandr -q | egrep "144\.00\*"
}

docker-clean() {
  docker ps -aq | xargs -r docker rm -f
  docker images -q -f="dangling=true" | xargs -r docker rmi -f
}

serve() {
  python -m http.server 8000
}

# upload a single file in PWD to transfer.sh
transfer() {
  curl --upload-file "$1" "https://transfer.sh/$1" | xclip -sel clip
}
ruby-env() {
  local -r gemdir="$(ruby -e 'print Gem.user_dir')"
  export PATH="${gemdir}/bin:$PATH"
}

steam-safe() {
  sudo systemctl stop docker
  sudo systemctl stop postgresql
  pm2 kill
  __GLVND_DISALLOW_PATCHING=1 steam
}

# -----------------------------------------------------------------------------
# system statistics/usage

mem() {
  free -t | grep Mem | awk '{ printf("%3.1f%%\n", $3*100/$2)}'
}
disk() {
  # Total usage of currently mounted logical drives
  df -l --total \
    | grep total \
    | awk '{printf("%3.1f%%\n", $3*100/$2)}'
}
cpu() { awk '{printf("%3.1f%%\n", $1*100/'"$(nproc)"') }' < /proc/loadavg ;}

iface() {
  # first interface with state UP
  ip link show | grep "state UP" | awk '{print $2}' | cut -d':' -f1 | head -n 1
}
network() {
  # transferred numbers are in first column, print everything with space separation
  local -r netdata=$(ip -s link show "$(iface)" | awk -v ORS=" " '{ print $1 }')
  # convert relevant numbers to gigabytes
  local -r RX=$(echo "$netdata" | cut -d" " -f4 | awk '{printf("%3.1fGB\n", $1/1073741824)}')
  local -r TX=$(echo "$netdata" | cut -d" " -f6 | awk '{printf("%3.1fGB\n", $1/1073741824)}')
  echo -e "Sent: ${TX}\nRecv: ${RX}"
}

localip() {
  ip addr show "$(iface)" | grep inet | awk '{ print $2 }'
}

# process tree
#
# pstree :: simple tree hiding kernel workers
# pstree f :: full tree
# pstree u [user] :: user tree for $USER or passed in user
pstree() {
  local -r full=$([ "$1" = "f" ] && echo "1")
  local usr=""
  if [ "$1" = "u" ]; then
    usr=$([ -n "$2" ] && echo "$2" || echo "$USER")
  fi
  local flags=""
  if [ -n "$full" ]; then
    flags="-e -o cputime,pid,user,args"
  elif [ -n "$usr" ]; then
    flags="U $usr -o cputime,pid,args"
  else
    # Simple multi-user, filtering away PPID 2
    flags="--ppid 2 --deselect -o cputime,pid,user,args"
  fi
  # shellcheck disable=SC2086
  ps $flags --forest --width $(($(tput cols)-1)) | ccze -A | less -RX
  # NB: the -1 is to compensate for what ccze puts in there
}

# -----------------------------------------------------------------------------
# http helpers

# http method url ['{json}']
http() {
  local -r method="${1^^}"
  if [[ $method =~ POST|PUT ]]; then
    jsondata=$(echo "-H Content-Type:application-json -d \"$3\"")
  fi
  echo curl -X "$method $2 ${jsondata}"
}

# -----------------------------------------------------------------------------
# scaffolding from templates folder

node-init() {
  find ~/.templates/npm/ -not -type "d" -exec cp {} "$PWD" \;
  pkginit
  local -r dir="$(basename "$PWD")"
  echo "# $dir" > README.md
  badgify >> README.md
  sed "s/BASENAME/$dir/g" readme.md >> README.md
  rm readme.md
}

cargo-init() {
  find ~/.templates/cargo/ -not -type "d" -exec cp {} "$PWD" \;
  # TODO: replace mycrate with basename
  #local -r dir="$(basename "$PWD")"
}

# -----------------------------------------------------------------------------
# misc node

node-deopts() {
  # shellcheck disable=SC2068
  node --trace_opt --trace_deopt --allow-natives-syntax $@
}

node-deps() {
  npm ls | grep -oE "[[:alnum:]\@\.]*" | sort -u
}

# -----------------------------------------------------------------------------
# documentation generation for gh-pages

# Do this AFTER bumping version in Cargo.toml and cargo package && cargo publish
rust-doc-update() {
  cargo doc
  local -r repo=$(basename "$PWD")
  echo "<meta http-equiv=refresh content=0;url=$repo/index.html>" > target/doc/index.html
  ghp-import -n target/doc
  git push -qf "git@github.com:clux/$repo.git" gh-pages
}

rust-doc-view() {
  cargo doc
  local -r repo=$(basename "$PWD")
  xdg-open "target/doc/$repo/index.html"
}

# -----------------------------------------------------------------------------
# more rust

rust-muslbuild() {
  docker run -v "$PWD:/volume" -w /volume -t clux/muslrust cargo build --release
  sudo chown "$USER" -R target
}

# -----------------------------------------------------------------------------
# extraction shortcuts

# insert xkcd tar joke here
extract () {
  if [ -f "$1" ] ; then
      case "$1" in
          *.tar.bz2)   tar xvjf "$1"    ;;
          *.tar.gz)    tar xvzf "$1"    ;;
          *.bz2)       bunzip2 "$1"     ;;
          *.rar)       unrar x "$1"     ;;
          *.gz)        gunzip "$1"      ;;
          *.tar)       tar xvf "$1"     ;;
          *.tbz2)      tar xvjf "$1"    ;;
          *.tgz)       tar xvzf "$1"    ;;
          *.zip)       unzip "$1"       ;;
          *.Z)         uncompress "$1"  ;;
          *.7z)        7z x "$1"        ;;
          *)           echo "unknown extension for '$1'" ;;
      esac
  else
      echo "$1 is not a valid file!"
  fi
}
# ball: output [inputs]
ball () { tar czf "$1.tar" "${@:2}" ;}
# 7zsplit output [inputs]
7zsplit() { 7z a "$1.7z" -mx0 -V500M "${@:2}" ;}

# -----------------------------------------------------------------------------
# Broxy + brotorr integrations

dl() { cd "$DOWNLOAD_DIR" || return 1 ;}

movies-diff () {
  diff -u <(ls /media/clux/TOOL/MP4/Movies/) <(ls /media/clux/Zorn/NewMP4/BluRay/)
}

# xdg-mime handler
broxy-download () {
  # shellcheck disable=SC2029
  ssh broxy "source ~/.path; source ~/.exports; ./brotorr/torrent \"$1\""
}

# Find flags for helpers
broxy-findflags() {
  echo -e "-not -name '.*' -not -regex '.*Trash.*' -not -name tmp -printf '%p\n'"
}
broxy-dirflags() { echo -e "-mindepth $1 -maxdepth $1 -type d" ;}

# Everything in DL - usually fetch from here
broxy-check() {
  # shellcheck disable=SC2029
  ssh broxy "cd dumptruck/DL && find . $(broxy-dirflags 1) $(broxy-findflags)"
}

# Everything
broxy-all() {
  # shellcheck disable=SC2029
  ssh broxy "cd dumptruck && find . $(broxy-dirflags 2) $(broxy-findflags)"
}

# Everything from last month
broxy-latest() {
  # shellcheck disable=SC2029
  ssh broxy "cd dumptruck && find . $(broxy-dirflags 2) -mtime -31 $(broxy-findflags)"
}

# Grab from broxy with a pattern with confirmation
broxy-grab() {
  local -r rs=$(broxy-all | grep "$1")
  echo "Will download:"
  echo "$rs"
  read -rp "Enter to continue.."
  echo "Starting download"
  echo "$rs" | while read -r line; do
    fldr=$(echo "$line" | cut -d '/' -f2-)
    echo "Downloading $fldr"
    rsync -cahzP -e ssh "broxy:/home/bro/dumptruck/$fldr" .
  done
}

# -----------------------------------------------------------------------------
# Publishing helpers

npm-patch() {
  npm version patch && git push && git push --tags && npm publish
}
npm-minor() {
  npm version minor && git push && git push --tags && npm publish
}
npm-major() {
  npm version major && git push && git push --tags && npm publish
}
