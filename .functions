#!/bin/bash

# -----------------------------------------------------------------------------
# opening helpers

vf() { vlc "$(fzf)" > /dev/null 2>&1 ;}
hf() { hx "$(fzf)" ;}
h() { hx . ;}

# -----------------------------------------------------------------------------
# zellij/guake + terminal mux helpers

# shellcheck disable=SC2068
rc() { zellij run -- $@ ;}
# shellcheck disable=SC2068
ra() { zellij run -- zsh -ic $@ ;}

# zellij tab from layout
zl() {
  local -r name="${PWD##*/}"
  local -r layout="$(cd ~/.config/zellij/layouts && fd . | fzf)"
  zellij action new-tab --layout "$HOME/.config/zellij/layouts/${layout}" --name="${name}"
}

# terminal mux helpers to rename the tab we do something
zz() {
  if [[ ! "${OSTYPE}" =~ "darwin" ]]; then
    guake --rename-tab="${PWD##*/}" -i "$(guake -g)"
  else
    zellij action rename-tab "${PWD##*/}"
  fi
}
zzh() {
  if [[ ! "${OSTYPE}" =~ "darwin" ]]; then
    guake --rename-tab="$1" -i "$(guake -g)"
  else
    zellij action rename-tab "$1"
  fi
  # shellcheck disable=SC2068
  ssh $@
}

# -----------------------------------------------------------------------------
# Key management via keychain

key() {
  local keys=""
  for k in "$@"; do
    case $k in
      tl) keys="2D67048E41E0AA6C $keys" ;;
      pass) keys="B71E94106D1B408B $keys" ;; # enc subkey
      sign) keys="5D4B685DE5BEAE01 $keys" ;; # signing subkey
      *) keys="${k}_id $keys" ;; # assume ssh key
    esac
  done
  echo "keychain --nogui --timeout $((16*60)) --quiet --host agent --agents ssh,gpg $keys" | sh
  source ~/.keychain/agent-sh
  source ~/.keychain/agent-sh-gpg
}
keys() {
  # join static list of gpg keys with dynamic list of ssh keys
  local -r keys="$( ( (fd --max-depth 1 -u --type f -g '*_id' ~/.ssh | cut -d'/' -f5 | sed 's/_id//g'); echo -e "tl\npass\nsign") | fzf )"
  # shellcheck disable=SC2086
  key $keys
}

# -----------------------------------------------------------------------------
# fzf interfaces

# pass clipboard through fzf lookup
passf() {
  local -r secret="$(cd ~/.password-store && fd .gpg | fzf --layout=reverse-list)"
  pass "${secret/%.gpg}" -c
}
# pass show everything after first line through fzf (first line is pw)
passt() {
  local -r secret="$(cd ~/.password-store && fd .gpg | fzf --layout=reverse-list)"
  pass "${secret/%.gpg}" | tail -n +2 | less
}

# chrome history
ch() {
  local cols sep open
  cols=$(( COLUMNS / 3 ))
  sep='{::}'
  open='xdg-open'

  if [[ "${OSTYPE}" =~ "darwin" ]]; then
    open="open"
    cp -f ~/Library/Application\ Support/Google/Chrome/Default/History /tmp/h
  else
    cp -f ~/.config/google-chrome/Default/History /tmp/h
  fi

  sqlite3 -separator $sep /tmp/h \
      "select substr(title, 1, $cols), url
      from urls order by last_visit_time desc" |
    awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' |
    fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | \
    xargs "${open}" > /dev/null
}

# systemd; follow / reload
sysf() {
  local -r unit="${1:-$(systemctl list-units --no-pager --no-legend | awk '{ print $1 }' | fzf)}"
  journalctl -u "$unit" -fl
}
sysr() {
  local -r unit="${1:-$(systemctl list-units --no-pager --no-legend | awk '{ print $1 }' | fzf)}"
  sudo systemctl daemon-reload
  sudo systemctl restart "$unit"
}

# -----------------------------------------------------------------------------
# package manager abstraction - mostly for my own memory

if [[ "${OSTYPE}" =~ "darwin" ]]; then
  qlist() { brew list "$1" ;}
  pakl() { brew leaves ;}
  # no pakf (cannot search registry for files)
  # no pakl (look at what symlinks point to instead)
  paki() { brew install "$1" ;}
  pakr() { brew rm "$1" ;}
elif grep -q "Arch Linux" /etc/os-release; then
  # list available packages:
  paks() { pacman -Ss "$1" ;}
  # list locally installed packages:
  pakl() { pacman -Qs "$1" ;}
  # what package owns local file:
  pakf() { pacman -Qo "$1" ;}
  # what package owns a file you don't have:
  pakq() { pacman -Fs "$1"; } # may need a pacman -Fy first
  # list files belonging to a package:
  qlist() { pacman -Ql "$1" ;}
  # install a package:
  paki() { sudo pacman -S "$1" ;}
  # remove a package and its dependencies recursively:
  pakr() { sudo pacman -Rs "$1" ;}
  # list available updates to installed packages:
  #canonical checkupdates
elif grep -qE "Ubuntu|Mint" /etc/os-release; then
  paks() { apt-cache search "$1"; }
  # the easier ones for this all perform network queries..
  pakl() { dpkg --get-selections | grep -v deinstall | awk '{ printf("%s\n", $1) }' | grep "$1" ;}
  pakf() { dpkg -S "$1" ;}
  pakq() { apt-file search "$1" ;} # needs apt-file installed + `apt-file update` called
  qlist() { dpkg-query -L "$1" ;}
  paki() { sudo apt-get install "$1" ;}
  pakr() { sudo apt-get remove "$1" ;}
elif lsb_release -ds | grep -qEi "Gentoo"; then
  paks() { eix -c "$1" ;}
  pakf() { equery belongs "$1" ;}
  # canonical qlist
  paki() { sudo emerge "$1" ;}
  pakr() { sudo emerge -cav "$1" ;}
  checkupdates() { eix -uc "$1" ;}
elif command -v yum &> /dev/null; then
  paks() { yum search "$1" ;}
  pakf() { yum whatprovides "$1" ;}
  qlist() { repoquery --list "$1" ;} # from yum-utils
  paki() { sudo yum install "$1" ;}
  pakr() { sudo yum remove "$1" ;}
elif grep -qE "Alpine Linux" /etc/os-release; then
  paks() { apk info -vv | grep "$1" ;}
  pakl() { apk search  "$1" ;} # needs an apk update first
  pakf() { apk info --who-owns "$1" ;}
  #pakq() {} # needs apk-file installed - go get github.com/jessfraz/apk-file outside
  qlist() { apk info -L "$1" ;}
  paki() { apk add --no-cache "$1" ;}
  pakr() { apk del "$1" ;}
fi

# -----------------------------------------------------------------------------
# misc

# Create a new directory and enter it
mkd() { mkdir -p "$@" && cd "$@" || return 1 ;}

docker-clean() {
  docker ps -aq | xargs -r docker rm -f
  docker images -q -f="dangling=true" | xargs -r docker rmi -f
  docker buildx prune
  # check with docker buildx du --verbose
}

serve() {
  python -m http.server 8000
}

# upload a single file in PWD to transfer.sh
transfersh() {
  curl --upload-file "$1" "https://transfer.sh/$1" | xclip -sel clip
}

# Not sure this works anymore - even on linux; renderer ps are not 1-1 with tabs :/
kill-tabs() { pkill -u "$USER" -f "chrome.*renderer" ;}

# horizontal ruler
hr() {
  echo "$(tput setaf 33)$(printf '%.sâ”€' $(seq 1 "$(tput cols)"))"
}

wifihotspot() {
  sudo create_ap wlp2s0 enp0s20f0u1 "Bathroom Cam 2" "$(pass network/ea-laptop)"
}


# -----------------------------------------------------------------------------
# gaming related linux hacks

# override monitor refresh rate
# super meat boy: refresh-rate 60
# everything else: refresh-rate 144
refresh-rate() {
  local -r rate="${1-144}"
  if [[ ${HOSTNAME} = kjttks ]]; then
    # Main screen refresh rate
    xrandr --output HDMI-0 --mode 1920x1080 --rate "$rate"
    xrandr -q | grep -E "$rate\.00\*"
  fi
}

steam-tf2() {
  export __GL_SYNC_TO_VBLANK=0
  export __GLVND_DISALLOW_PATCHING=1 # helped tf2 in the past
  steam
}

steam-mesa-old() {
  # A helper wrapper that made an older mesa laptop work better
  # shellcheck disable=SC2016
  LD_PRELOAD='/usr/$LIB/libstdc++.so.6 /usr/$LIB/libgcc_s.so.1 /usr/$LIB/libxcb.so.1 /usr/$LIB/libgpg-error.so' steam
}

q3() {
  set -x
  # Get most of quake3 from https://aur.archlinux.org/quake3-cpma.git (not pak0.pk3)
  export __GL_SYNC_TO_VBLANK=0
  # Need alsa-oss package and need to enable oss kernel modules
  sudo modprobe snd_seq_oss
  sudo modprobe snd_pcm_oss
  sudo modprobe snd_mixer_oss
  # Find correct card by looking in /proc/asound/cards
  # Mine jumps around, but its identifier is STX (Asus Xonar STX) - map to number:
  local -r cardid=$(grep STX /proc/asound/cards | awk '{print $1}')
  # Give DMA Access
  # NB: If you screw with this badly and it doesn't work, boot.
  echo "quake3.x86 0 0 direct" | sudo tee "/proc/asound/card${cardid}/pcm0p/oss"
  echo "quake3.x86 0 0 disable" | sudo tee "/proc/asound/card${cardid}/pcm0c/oss"
  # Have "seta snddevice /dev/dsp${cardid}" in your q3config.cfg
  # Or use this start command twice (for some reason it doesn't take first start)
  aoss quake3-cpma +"seta snddevice /dev/dsp${cardid}"
  # Do not open chrome and start playing music in the background
  # First sound you hear after boot should be quake
}

# -----------------------------------------------------------------------------
# misc node/py

node-deopts() {
  # shellcheck disable=SC2068
  node --trace_opt --trace_deopt --allow-natives-syntax $@
}

node-deps() {
  npm ls | grep -oE "[[:alnum:]\@\.]*" | sort -u
}

npm-patch() {
  npm version patch && git push && git push --tags && npm publish
}
npm-minor() {
  npm version minor && git push && git push --tags && npm publish
}
npm-major() {
  npm version major && git push && git push --tags && npm publish
}

venv() {
  if [ -d venv ]; then
    source venv/bin/activate
  elif [ -d .venv ]; then
    source .venv/bin/activate
  else
    python3 -m venv venv
    source venv/bin/activate
    pip install -r requirements.txt
  fi
}

# -----------------------------------------------------------------------------
# extraction shortcuts

# insert xkcd tar joke here
extract () {
  if [ -f "$1" ] ; then
      case "$1" in
          *.tar.bz2)   tar xvjf "$1"    ;;
          *.tar.gz)    tar xvzf "$1"    ;;
          *.tar.xz)    tar xvJf "$1"    ;;
          *.bz2)       bunzip2 "$1"     ;;
          *.rar)       unrar x "$1"     ;;
          *.gz)        gunzip "$1"      ;;
          *.tar)       tar xvf "$1"     ;;
          *.tbz2)      tar xvjf "$1"    ;;
          *.tgz)       tar xvzf "$1"    ;;
          *.zip)       unzip "$1"       ;;
          *.Z)         uncompress "$1"  ;;
          *.7z)        7z x "$1"        ;;
          *)           echo "unknown extension for '$1'" ;;
      esac
  else
      echo "$1 is not a valid file!"
  fi
}
# ball: output [inputs]
ball () { tar czf "$1.tar" "${@:2}" ;}
# 7zsplit output [inputs]
7zsplit() { 7z a "$1.7z" -mx0 -V500M "${@:2}" ;}

# -----------------------------------------------------------------------------
# storage manipulation (mostly linux only)

openimage() {
  local types='*.jpg *.JPG *.png *.PNG *.gif *.GIF *.jpeg *.JPEG'

  cd "$(dirname "$1")" || true
  local -r file=$(basename "$1")

  # shellcheck disable=SC2086
  feh -q $types --auto-zoom \
    --sort filename --borderless \
    --scale-down --draw-filename \
    --image-bg black \
    --start-at "$file"
}

dslrdump() {
  cd /media/gauss/IMG/ || return
  mkd "$(date +%F)"
  gphoto2 --get-all-files
  #gphoto2 --delete-all-files doesn't work :( - pantheon-photos works though
}

# veracrypt shortcuts
vc1() {
  sudo echo "got sudo" # cache sudo first
  # For some reason the below cmd does not work without non-interactive in text mode
  veracrypt -t --mount /dev/sdc1 --slot=1 --verbose -p "$(pass drives/turing)" --non-interactive
  export HISTFILE=/dev/null
  cd /media/veracrypt1 || false
}
vc2() {
  sudo echo "got sudo" # cache sudo first
  # For some reason the below cmd does not work without non-interactive in text mode
  veracrypt -t --mount /dev/sde1 --slot=2 --verbose -p "$(pass drives/hilbert)" --non-interactive
  export HISTFILE=/dev/null
  cd /media/veracrypt2 || false
}
vcc() {
  cd || true
  veracrypt --text --dismount /dev/sdc1 --dismount /dev/sde1
  exit
}

# -----------------------------------------------------------------------------
# Broxy + brotorr integrations (massively out of date)

# Download dir for `dl` + brotorr
export DOWNLOAD_DIR=~/Downloads
if [[ $HOSTNAME = kjttks ]]; then
  export DOWNLOAD_DIR=/media/gauss/DL
elif [[ $HOSTNAME = broxy ]]; then
  export DOWNLOAD_DIR=/media/dumptruck/DL
fi

# Download dir for `dl` + brotorr
dl() { cd "$DOWNLOAD_DIR" || return 1 ;}

movies-diff () {
  diff -u <(ls /media/clux/TOOL/MP4/Movies/) <(ls /media/clux/Zorn/NewMP4/BluRay/)
}

# xdg-mime handler
broxy-download () {
  # shellcheck disable=SC2029
  ssh broxy "source ~/.path; source ~/.exports; ./brotorr/torrent \"$1\""
}

# Find flags for helpers
broxy-findflags() {
  echo -e "-not -name '.*' -not -regex '.*Trash.*' -not -name tmp -printf '%p\n'"
}
broxy-dirflags() { echo -e "-mindepth $1 -maxdepth $1 -type d" ;}

# Everything in DL - usually fetch from here
broxy-check() {
  # shellcheck disable=SC2029
  ssh broxy "cd dumptruck/DL && find . $(broxy-dirflags 1) $(broxy-findflags)"
}

# Everything
broxy-all() {
  # shellcheck disable=SC2029
  ssh broxy "cd dumptruck && find . $(broxy-dirflags 2) $(broxy-findflags)"
}

# Everything from last month
broxy-latest() {
  # shellcheck disable=SC2029
  ssh broxy "cd dumptruck && find . $(broxy-dirflags 2) -mtime -31 $(broxy-findflags)"
}

# Grab from broxy with a pattern with confirmation
broxy-grab() {
  local -r rs=$(broxy-all | grep "$1")
  echo "Will download:"
  echo "$rs"
  read -rp "Enter to continue.."
  echo "Starting download"
  echo "$rs" | while read -r line; do
    fldr=$(echo "$line" | cut -d '/' -f2-)
    echo "Downloading $fldr"
    rsync -cahzP -e ssh "broxy:/home/bro/dumptruck/$fldr" .
  done
  notify-send "completed download of $1"
}

# -----------------------------------------------------------------------------
# system statistics/usage (linux only)

mem() {
  free -t | grep Mem | awk '{ printf("%3.1f%%\n", $3*100/$2)}'
}
disk() {
  # Total usage of currently mounted logical drives
  df -l --total \
    | grep total \
    | awk '{printf("%3.1f%%\n", $3*100/$2)}'
}
cpu() { awk '{printf("%3.1f%%\n", $1*100/'"$(nproc)"') }' < /proc/loadavg ;}
# average cpu frequency based on current mean info across cores /proc/cpuinfo divided by max
cpufreq() {
  local -r maxkhz="$(cat /sys/devices/system/cpu/cpu1/cpufreq/scaling_max_freq)"
  local -r current_mhz="$(grep 'cpu MHz' /proc/cpuinfo | awk '{print $4}' | datamash mean 1)"
  echo "scale=2; 100* $current_mhz * 1000 / $maxkhz" | bc -l | xargs printf "%s%%\n"
}

iface() {
  # first interface with state UP
  ip link show | grep "state UP" | awk '{print $2}' | cut -d':' -f1 | head -n 1
}
network() {
  # transferred numbers are in first column, print everything with space separation
  local -r netdata=$(ip -s link show "$(iface)" | awk -v ORS=" " '{ print $1 }')
  # convert relevant numbers to gigabytes
  local -r RX=$(echo "$netdata" | cut -d" " -f4 | awk '{printf("%3.1fGB\n", $1/1073741824)}')
  local -r TX=$(echo "$netdata" | cut -d" " -f6 | awk '{printf("%3.1fGB\n", $1/1073741824)}')
  echo -e "Sent: ${TX}\nRecv: ${RX}"
}

localip() {
  ip addr show "$(iface)" | grep inet | awk '{ print $2 }'
}
