[alias]
  # COMMON
  s = status -s
  d = diff
  dc = diff --cached
  c = commit --verbose
  a = add
  p = pull
  m = checkout master

  # OCCASIONAL
  amend = commit --amend
  ping = "!f() { git commit --allow-empty -m \"ping hooks - $(date +%Y-%m-%d)\"; }; f"
  uncommit = reset --soft HEAD^
  unstage = reset HEAD
  count = shortlog --summary --numbered
  ps = !git pull --recurse-submodules && git submodule update --init --recursive
  chk = diff --cached --check
  stat = diff --stat
  rc = = clone --recursive
  top = rev-parse --show-toplevel
  # re-apply tweaked hooks
  reinit = !sh -c 'rm -rf .git/hooks/** && git init'
  # diff between the state $1 revisions ago and HEAD
  di = !"d() { git diff --patch-with-stat HEAD~$1; }; git diff-index --quiet HEAD -- || clear; d"
  # Listers
  tags = tag -l
  branches = branch -a
  remotes = remote -v

  # BRANCH HELPERS
  # push a small tweak to a PR
  yolo = !git add -u && git  commit --amend --no-edit && git push -f
  # Delete merged branches
  dm = "!git branch --merged | grep -v '\\*' | xargs -n 1 git branch -d"
  # Switch to a branch, creating it if necessary
  go = "!f() { git checkout -b \"$1\" 2> /dev/null || git checkout \"$1\"; }; f"
  # Checkout a pull request from origin (of a github repository)
  pr = !"f() { git fetch origin pull/$1/head:pr-$1; git checkout pr-$1; }; f"
  # Interactive rebase with the given number of latest commits
  reb = "!f() { git rebase -i HEAD~$1; }; f"

  # MISC
  # add all untracked files to .gitignore
  untracked = ls-files --others --exclude-standard
  # ignore all untrackeds (if first time having gitignore, don't ignore that)
  ignore = !git untracked | grep -v .gitignore >> .gitignore && git add .gitignore
  # open github/github enterprise changesets in the browser
  open = "!f() { xdg-open \"https://$(echo $(git config --get remote.origin.url) | sed 's|^http.://||' | sed 's|^git@||' | tr : '/' | sed 's|.git$||')/commit/$1\"; }; f"
  # go $1 steps back in reflog
  undo = "!f() { git reset --hard $(git rev-parse --abbrev-ref HEAD)@{${1-1}}; }; f"

  # FINDERS
  # Find commits by source code
  fc = "!f() { git log --pretty=format:'%C(yellow)%h  %Cblue%ad  %Creset%s%Cgreen  [%cn] %Cred%d' --decorate --date=short -S$1; }; f"
  # Find commits by commit message
  fm = "!f() { git log --pretty=format:'%C(yellow)%h  %Cblue%ad  %Creset%s%Cgreen  [%cn] %Cred%d' --decorate --date=short --grep=$1; }; f"
  # Find tags containing commit
  ft = "!f() { git describe --always --contains $1; }; f"
  # Find branches containing commit
  fb = "!f() { git branch -a --contains $1; }; f"

  # IDENTITY
  ea = !git config --local user.name \"Eirik Albrigtsen\" && \
        git config --local user.email \"ealbrigt@cisco.com\"
  clux = !git config --local user.name \"clux\" && \
          git config --local user.email \"analsandblaster@gmail.com\"
  # set who i am on fresh clones (cd's into dirname and calls one of the above)
  idclone ="!f() { cd $(echo $2 | cut -d"/" -f2) && git $1 && cd -; }; f"
  whoami = !sh -c 'echo \"$(git config --get user.name) <$(git config --get user.email)>\"'

  # shortcuts for cloning and setting identities correctly
  github ="!f() { git clone git@github.com:$1.git && git idclone clux $1; }; f"
  gitlab ="!f() { git clone git@gitlab.com:$1.git && git idclone clux $1; }; f"
  bitbucket ="!f() { git clone git@bitbucket.org:$1.git && git idclone clux $1; }; f"
  sqbu = "!f() { git clone git@sqbu-github.cisco.com:$1.git && git idclone ea $1; }; f"
  acano = "!f() { git clone gitosis@acanogit.pv.acano.com:$1.git; }; f"

  # multi-clone shortcuts
  hub ="!f() { for i in $@; do git github clux/$i; done; }; f"
  lab ="!f() { for i in $@; do git gitlab clux/$i; done; }; f"
  bb ="!f() { for i in $@; do git bitbucket clux/$i; done; }; f"

  # initializing and setting identities correctly
  # usage: `git new ea` or `git new clux`
  initial ="!f() { [ -n "$1" ] && git $1 && git commit --allow-empty -m init; }; f"
  new ="!f() { [ ! -d ".git" ] && git init && git add . && git initial $1; }; f"

[user]
  signingkey = 0xA876A6CD26914D42

[push]
  default = simple

[pager]
  diff = /usr/share/git/diff-highlight/diff-highlight | less
  show = /usr/share/git/diff-highlight/diff-highlight | less
  log = /usr/share/git/diff-highlight/diff-highlight | less

[interactive]
  diffFilter = /usr/share/git/diff-highlight/diff-highlight

[apply]
  # Detect whitespace errors when applying a patch
  whitespace = fix

[color "diff"]
  meta = yellow bold
  frag = magenta bold # line info
  old = red # deletions
  new = green # additions

[color "status"]
  added = yellow
  changed = green
  untracked = cyan

[init]
  templatedir = ~/.templates/git
